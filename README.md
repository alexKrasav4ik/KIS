# KIS
Панарин Александр Андреевич, задача 5
как скомпилировать и запустить: g++ main.cpp, ./a.out

В чем суть решения: есть два глобально разных подхода:
1)если включать костер очень дорого, то давайте просто пытаться переходить в соседние клетки, и если не получается, то крутиться. Это ровно DFS(реализовано в функции dfs). В ней же
я оптимально делаю повороты, учитываю все направления и так далее. Работает, но на графах, где много стен, выполняет много лишних действий

2)Давайте делать так: будем зажигать костер в клетке, но если мы знаем, что рядом с клеткой есть 3 стены, то не будем. Вот мы зажгли костер, давайте обновим следующие множества(set'ы):
good_points - хорошие точки
bad_point - стены
После этого при помощи алгоритма Дейкстры найдем ближайший к нам непосещенный пункт V(Дейкстра сразу же восстанавливает путь), пометим нашу текущую клетку как "использованную", и перейдем
в V. И так будем повторять, пока размер good_points не станет равен количеству использованных клеток.

Второй подход ЗНАЧИТЕЛЬНО экономит операции 1 и 2 на графах, где много стен.

Некоторые решения: я полностью строю граф из всех хороших вершин во втором решении, каждая вершина - это (клетка, направление). Я в граф добавляю все возможные ребра между состояниями,
после чего запускаю классическую Дейкстру. Поэтому, например, у меня граф размера good_points.size() * 4.
