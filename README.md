# KIS
Панарин Александр Андреевич, задача 5
как скомпилировать и запустить: g++ main.cpp, ./a.out

В чем суть решения: есть два глобально разных подхода:
1)если включать костер очень дорого, то давайте просто пытаться переходить в соседние клетки, и если не получается, то крутиться. Это ровно DFS(реализовано в функции dfs). В ней же
я оптимально делаю повороты, учитываю все направления и так далее. Работает, но на графах, где много стен, выполняет много лишних действий

2)Давайте делать так: будем зажигать костер в клетке, но если мы знаем, что рядом с клеткой есть 3 стены, то не будем. Вот мы зажгли костер, давайте обновим следующие множества(set'ы):
good_points - хорошие точки
bad_point - стены
После этого при помощи алгоритма Дейкстры найдем ближайший к нам непосещенный пункт V(Дейкстра сразу же восстанавливает путь), пометим нашу текущую клетку как "использованную", и перейдем
в V. И так будем повторять, пока размер good_points не станет равен количеству использованных клеток.

Второй подход ЗНАЧИТЕЛЬНО экономит операции 1 и 2 на графах, где много стен.
